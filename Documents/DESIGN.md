# 아키텍처와 전반설계

## 아키텍처
* 마이크로서비스 아키텍처를 적용한다.
* 서비스간의 통신은 api와 kafka를 사용하며 api스펙을 상세하게 제공한다.
* 도메인 모델패턴을 사용하여, 엔티티에 비즈니스 로직을 작성한다.
* mvc패턴의 주요 계층인 service, controller, repository에는 **선언형**으로 프로그래밍한다.
* 계층은 반드시 분리하며, controller와 repository를 연결하고, 비즈니스 로직을 선언하여 호출만 하는 service 계층에서만 dto와 entity를 모두 사용한다.

## command의 처리
* command(명령)은 비동기가 불가능한 경우가 아니라면 반드시 **비동기**로 처리한다.
* 반드시 void 형의 한해서만 적용하며,
* delete 연산의 경우 순서를 따져서 삭제해야하는 경우 **동기**로 처리한다.

## 예외처리
* 예외는 반드시 custom으로 예외를 만들어 처리한다.
* custom으로 만든 예외를 controller advice에서 캐치하여 client에게 response를 넘길수있도록 한다.
* 특히 **validator**의 경우 모든 함수를 void로 하여
* 값이 검증되지 않을때 예외를 터뜨리는 방식으로 하여
* 컨트롤러에서 선언형 프로그래밍이 온전히 유지될 수 있도록 한다.

## 동시성의 처리
* 동시성 문제가 발생할때 더티체킹을 이용하는 경우라면
* jpa의 표준스펙인 **비관적 락**을 사용하여 처리한다.
* 특히나 많은 양의 요청일 경우 **비관적 락**을 적극이용한다.

## 데이터 조회
### 단건 데이터 조회
* 단건은 엔티티 그대로 조회하고
* 서비스 계층에서 controller 계층으로 옮길때에는
* Mapper를 사용해서 매핑하여 dto의 형태로 리턴한다.
### 대량의 데이터 조회
* 대량의 데이터를 조회할 때에는 dto projection을 사용한다.
* 매퍼를 사용하지 않고, 바로 dto로 값을 조회한다.
* 이를 통해 조회 성능을 향상시킬 수 있다.

## 성능 향상은 범용적인 것 위주로 하라
* 성능 향상은 성능을 더욱 많이 올릴 수 있는 것들 위주로 한다.
* 특히나 성능 이슈는 대부분 조회에서 발생하며,
* 더욱이 대량의 데이터를 조회하는 경우 발생한다.
* 대량의 데이터 조회의 경우에는 dto projection, 인덱스 등 성능을 끌어올릴 수 있는 최대로 성능을 끌어올린다.
* 이에 대한 설명은 [스타일가이드](https://github.com/liveforone/study/blob/main/%5B%EB%82%98%EB%A7%8C%EC%9D%98%20%EC%8A%A4%ED%83%80%EC%9D%BC%20%EA%B0%80%EC%9D%B4%EB%93%9C%5D/r.%20%EC%84%B1%EB%8A%A5%ED%96%A5%EC%83%81%EC%9D%80%20%EB%B2%94%EC%9A%A9%EC%A0%81%EC%9D%B8%EA%B2%83%20%EC%9C%84%EC%A3%BC%EB%A1%9C.md)에도 잘 나타나 있다.

## 쿼리 메서드
* 쿼리는 validator를 위한 단건조회(+하나의 컬럼값 리턴)를 반드시 제공해야한다.
* 검색 쿼리를 반드시 like%를 이용하여 인덱스를 탈 수 있도록 한다.
* 리파지토리 유틸클래스를 이용해 복잡한 리파지토리를 깔끔하게 유지한다.
* [Q클래스 중복](https://github.com/liveforone/middle/blob/master/Documents/REPO_UTIL_DUPLICATE_QCLASS.md)의 경우에는 링크를 참조하라.
* 하나의 쿼리로 여러 조건을 처리할 수 있는 동적쿼리를 적극활용해 최대한 적은 함수를 유지할 수 있도록 한다.

## 파라미터 디폴트 값 설정
* 파라미터는 디폴트 값을 설정한다.
* 문자 혹은 숫자 타입의 모든 값에 디폴트 값을 적용한다.

## provide controller
* 다른 마이크로 서비스에 데이터를 제공하는 provide controller의 경우
* 특정 마이크로 서비스에 종속되도록 만들지 않는다.
* 글로벌로 처리될 수 있도록 다양한 형태의 http method를 제공한다. => gateway가 이러하다.

## api
* 한 화면에 종속되는 api는 만들지 않는다.
* 필요한 데이터만 리턴하고, 화면에서는 필요한 데이터에 맞게 api들을 호출해서 데이터를 합치면 된다.
* 유연한 동작과 프론트/백을 나눈 이유를 상기하며 api 스펙을 설계하고 구현하라

## 테스트
* 테스트는 서비스 계층과 엔티티를 모두 테스트하라
* 엔티티에 비즈니스 로직이 있는 도메인 모델 패턴의 경우
* 반드시 엔티티도 테스트하여 비즈니스 로직을 db없이 검증하고,
* 서비스 계층을 테스트 하여 트랜잭션 상황에서의 테스트도 진행하라