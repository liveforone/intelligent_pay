# 마이크로 서비스 통합 설계

## 서비스 분리 원칙
* DB 가 있던 없던, DB 유무에 관계없이 **역할**과 **책임**이 다르다면 과감히 분리한다.
* 분리시키면 서비스간 결합도가 낮아지기 때문에 의존성이 줄어들어 유지보수와 확장이 훨씬 유연하고 쉬어진다.

## 프로젝트 통합
* 마이크로 서비스 아키텍처의 장점은 관심사 분리 + 서비스의 연결이다.
* intelligent 시리즈의 프로젝트들은 하나의 디스커버리 서버로 통합된다.
* 다만 각각의 게이트웨이는 분리하여 요청에 알맞는 서비스로 라우팅되게한다.
* 일례로 pay서비스와 store 서비스는 gateway 서버는 다르지만 discovery 서버는 동일한것을 사용하여, 두 프로젝트를 안정적으로 통합할 수 있다.

## 프로젝트 제작 시 디스커버리 서버
* 첫번째로 제작하는 pay 서비스에만 디스커버리 서버를 두고
* 두번째 프로젝트부터는 게이트웨이만 만든다.(게이트웨이 네이밍 다르게함.)
* 유저서비스처럼 이름이 겹치는 서비스는 절대로 네이밍을 그대로 하면안된다.
* yml 안의 application 이름을 다르게 해야한다.
* 일례로 pay 프로젝트의 유저서비스는 pay-user-serivce라는 이름을 가진다.

## 제공 api의 경우 필터 해제
* 내부의 마이크로서비스와 외부의 타 서비스에 제공하는 api는 
* auth 필터를 해제하여 제공한다.
* 이러한 api들은 body로 필요한 정보가 모두넘어오고 
* validatoin을 하기 때문에 필터를 거치지 않아도 된다.

## 트랜잭션 연쇄호출
* 각 프로젝트 안에서는 트랜잭션 -> 트랜잭션 -> 트랜잭션
* 처럼 연쇄적으로 트랜잭션이 호출되는 일이 종종 발생한다.
* 이러한 경우에는 반드시 중간에 장애가 발생할 상황을 염두하여 서킷브레이커 등을 두어 잘 처리하고
* 반드시 오류가 없도록 해야한다.

## 서비스간 통신
* 서비스간에는 최대한 주고받는 데이터(정보)를 꼭 필요한 것만 두고 최소화시킨다.
* 일례로 다른 서비스에 트랜잭션을 발생시키는 command(명령)의 경우 
* boolean 값으로 소통을 하여 앞의 명령의 영향에 따라 내부 명령을 달리하는 서비스에서 가볍고 효과적으로 처리할 수 있다.
* 대표적으로 해당 프로젝트에서 계좌 서비스와 입출금/결제 서비스가 그러한 관계를 가진다.

## 서비스 간 통신시 주의점
* 페인 클라이언트 사용시 http method 매핑과는 별개로,
* @RequestBody를 사용하면 post, put 등의 command로
* @PathVariable, @RequestParam을 사용하면 get으로 인식한다.
* 이를 주의하라.