# Intelligent Pay
* 간편 결제+송금 서비스 입니다.
* 확장에 열려있고, 유지보수가 쉬운 시스템을 만들기위해 노력하였습니다.
* Intelligent라는 가상의 회사에 여러 사업들이 이루어진다는 컨셉을 가지고 프로젝트가 진행되었습니다.
* 대부분의 서비스는 결제작업이 필요합니다. 그러나 모든 서비스에 결제를 진행하는 부분을 넣기에는 부적절하다고 판단하였고,
* 간편송금과 Intelligent의 서비스(사업)들에서 결제가 필요할때 Intelligent Pay를 사용해 간펼결제를 처리할 수 있도록도록 하였습니다.
* 즉 Intelligent의 모든 서비스에서 결제가 필요한 경우 Intelligent Pay 서비스를 이용해 결제를 처리합니다.
* 이 프로젝트는 Intelligent 회사의 첫 서비스(사업)이자 모든 서비스의 결제를 담당하는 중요한 프로젝트입니다.
* **"확장성"**, **"유지보수 간편성"**, **"자사 내 타 서비스와 연결성"**, **객체지향적인 설계/구현**
* 위의 4가지 키워드를 집중적으로 다룬 프로젝트입니다.

# 0. 목차
1. [프로젝트 소개](#1-프로젝트-소개)
2. [프로젝트 고민](#2-프로젝트-고민)
3. [서비스별 문서](#3-서비스별-문서)
4. [프로젝트 설계 문서](#4-프로젝트-설계-문서)
5. [Intelligent Pay를 지원하는 서비스](#5-intelligent-pay를-지원하는-서비스)

# 1. 프로젝트 소개
* [Intelligent 시리즈 소개](https://github.com/liveforone/intelligent_pay/blob/master/Documents/INTELLIGENT_COMPANY.md)
* [프로젝트 소개](https://github.com/liveforone/intelligent_pay/blob/master/Documents/INTRODUCTION.md)

# 2. 프로젝트 고민점

# 3. 서비스별 문서
* 서비스별 **요구사항**과 **설계**, **api 스펙**이 모두 기술되어 있습니다.
* [회원(user) 서비스]()
* [계좌(bankbook) 서비스]()
* [거래내역(record) 서비스]()
* [입출금(statement) 서비스]()
* [결제(pay) 서비스]()

# 4. 프로젝트 설계 문서
* [아키텍처와 전반설계](https://github.com/liveforone/intelligent_pay/blob/master/Documents/DESIGN.md)
* [DB 설계와 모델링]()
* [마이크로 서비스 통합 설계]()
* [화면 설계]()
* [수익모델]()

# 5. Intelligent Pay를 지원하는 서비스
* [Intelligent Store]() : 예정(제작 미완료)
* [Intelligent Booking]() : 예정(제작 미완료)

## 동시성
* 출금할때 보통 발생하는데, 이 프로젝트에서는 걱정하지 않아도된다.
* 이유는 자동이체가 지원되지 않는다. 즉 외부에서 출금 request를 하지 않는다.
* 출금을 하는 경우는 딱 한번 결제시에 존재하며, 결제를 다양하게 하지 않기때문에 동시성문제에서 자유롭다.

## 락
낙관적락은 update쿼리에 쓸수 없고, select 쿼리에만 쓸수 있다.
다만 update쿼리에는 비관적 락은 사용가능하다.
문제는 update에 낙관적 락을 걸 수 없으므로, 오로지 더티체킹으로만 변경할때 낙관적락이 유용한데, 업데이트시 조건을 넣는등 임의의 코드를 날릴때에는 사용이 불가능하다.
접근이 많은경우, 일례로 좋아요 수나, 상품의 수량같은 것에는 낙관적락이 좋으나,
접근이 별로없는 계좌나(동시성 발생확률이 낮음), 예약시스템(가게당 예약이 몇개 없음)의 경우에는 비관적 락이 더 좋다.
jpa에서 @Version 어노테이션을 붙인 버전 필드를 관리한다.
따라서 업데이트 쿼리가 나가면 자동으로 version 필드를 + 1한다.
그러나 벌크연산에서는 jpa를 무시하므로, 임의로 version의 값을 +1 해주어야한다.
쿼리 dsl에서는 .setLockMode(LockModeType.OPTIMISTIC)로 락을 건다.
예외 : OptimisticLockingFailureException
임의의 쿼리, 즉 직접 작성한 update쿼리에서도 version이 자동으로 잘 업데이트 되는지 확인

## 비밀번호 -> 설계
회원 비밀번호랑 계좌 비밀번호를 다르게 해야함.

## 벌크연산
여러값을 바꾸는 벌크연산 후에는 em.clear로 영속성 컨텍스트를 비워주어야 데이터 불일치가 해결된다.
벌크연산과 일반 update를 고려해서 쿼리를 짜라.
동시성 제어시 피해보지 않도록 설계해야한다.

## 주요 포인트
api + DB + 함수 + 마이크로서비스 : 의존성 제거하기 + 모듈화 + 응집도 높이기 + 확장/유지보수에 유연하게 대처가능

## 거래내역 서비스
입출금은 입출금, 거래의 경우 상품제목을 간략히 title에 저장한다.
인덱스는 연으로 검색, 연 + 월로 검색으로 두었다.
왜냐하면 연 검색은 연 검색 단건이고,
월 검색을 하려면 연도가 다 다르기때문에 반드시 연 검색이필요하다. 따라서 월검색 인덱스는 연 + 월 검색 인덱스로 구성해야한다.
제목으로 검색쿼리를 만든다.

## 입출금서비스
입금 => 외부 은행계좌에서 pay 계좌로 송금처리하여 pay의 포인트로 전환
외부계좌로 출금시 1% 수수료 
항상 먼저 잔액을 체크하도록 계좌 서비스에 command 요청을 하여 bool 값을 리턴받고 진행한다.
외부로부터 입금을 받을때에는 상관없다. 그것은 외부 타행 계좌 사정이기 때문이다. 출금이나 결제 시에는 반드시 계좌를 체크한다.
입출금 시에는 반드시 입출금 금액이 잔액을 초과하는지 확인
더티체킹한다.

## 결제 서비스
결제 시에는 반드시 입출금 금액이 잔액을 초과하는지 확인
더티체킹한다.

## 기능
카카오페이처럼 자체 머니 방식으로 하기.
타은행 계좌에 이체와 현 계좌로의 이체가 모두가능함
이커머스 서비스에서 계좌 잔액 확인할 수 있도록 api제작
송금은 구현가능하나, 결제의 경우에는 api를 통해 atm입출금 같은 느낌으로 처리하면된다.
조건은 카드를 긁거나, qr을 찍었을때, 또는 온라인으로 결제하여 위의 api로 들어왔다고 가정하면된다.
pg처럼 외부에 제공하는 api도 있어야함.

## api, db, 함수 의존성 최소화 - 고민점
api를 종속적으로 만들지 말아라. db도 나누고, 도메인도 나누고(마이크로서비스), api도 마치 함수처럼 나눈다. 
마이페이지를 위한 함수를 만들지말고 여러군데에서 사용할 수있도록 하기위해 함수를 만드는 것 처럼 api도 그러하다. 
db를 설계하고, 전체 아키텍처를 설계할때도 마찬가지이지만 성능은 맨 마지막에 고려해야한다. 
왜냐하면 성능을 튜닝하는 법은 너무 많기 때문이다. 성능에 목매면 설계가 박살날수있다.
설계할때 프론트 단까지 모든 api를 설계하고, 백엔드는 프론트에 전달해줄 api만 만들면된다. 
백엔드에서 모든 api를 다 처리하려고하니깐 문제가 생겼던 것이다. 
프론트와 백은 분리가되어있으니 백은 오로지 데이터 전달을 위한 통신용 api설계에만 집중하면 된다.
-> 마치 아래에서 소개된 상품을 조회할때 여러 서비스에서 필요한 데이터들을 가져와 최종적으로 조합하듯 말이다.
-> 데이터를 아주 섬세하게 저장하고 섬세하게 가져오자!!
-> 외부 api로 데이터를 가져오는것을 너무 두려워 해선 안될것 같음.

## 할일
* 화면설계에는 말그대로 화면의 api가
* 서비스별 설계 문서에는 제공하는 api스펙이 나타난다.
* 두 문서는 프로젝트 시작 바로 직전에 작성한다.
* 일례로 화면에는 회원 정보 api를 두고, 서비스 문서에는 간단한 회원 정보, 계좌서비스에서는 잔액 제공 등의 api가 존재할 수 있다. 이렇게 통합시켜서 진행하고, 절대로 화면에 종속되도록 설계하거나, 서비스 내의 api가 해당 서비스의 화면을 담당해야한다는 관념에서 벗어나야한다.

## 명령어 -> detach 실행 편리함을 위한
```
cd C:\Users\KYC\study\intelligent_pay\discovery-service\discovery-service\build\libs
```